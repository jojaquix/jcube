/*
 jcube
*/

/** 
 *  Cube buffer redered by isr routine
 *  each layer has 16 leds 
 *  1 on a bit means On, 0 means Off
 */
static uint8_t layer = 0;
static uint16_t cube_buffer[] = 
{
  0xffff,//layer 1
  0xffff,//layer 2
  0xffff,//layer 3
  0xffff //layer 4
};


static uint16_t test_secuences[] = {
  0x000f, 0x000f, 0x000f, 0x000f,
  0x00f0, 0x00f0, 0x00f0, 0x00f0,
  0x0f00, 0x0f00, 0x0f00, 0x0f00,
  0xf000, 0xf000, 0xf000, 0xf000,

  0x0009, 0x000f, 0x0009, 0x0006,
  0x0090, 0x00f0, 0x0090, 0x0060,
  0x0900, 0x0f00, 0x0900, 0x0600,
 

  0x9000, 0xf000, 0x9000, 0x6000,
  0x6666, 0x6666, 0xffff, 0xffff,
  0x6666, 0xffff, 0xffff, 0x6666,
  0xffff, 0xffff, 0x6666, 0x6666,


  //Columns rotating 
  0x0001, 0x0001, 0x0001, 0x0001,
  0x0002, 0x0002, 0x0002, 0x0002,
  0x0004, 0x0004, 0x0004, 0x0004,
  0x0008, 0x0008, 0x0008, 0x0008,

  0x0080, 0x0080, 0x0080, 0x0080,
  0x0800, 0x0800, 0x0800, 0x0800,
  0x8000, 0x8000, 0x8000, 0x8000,
  0x4000, 0x4000, 0x4000, 0x4000,
  
  0x2000, 0x2000, 0x2000, 0x2000,
  0x1000, 0x1000, 0x1000, 0x1000,
  0x0100, 0x0100, 0x0100, 0x0100,
  0x0010, 0x0010, 0x0010, 0x0010,
  //

  //Rotation around x
  0x000f, 0x0000, 0x0000, 0x0000,
  0x0000, 0x000f, 0x0000, 0x0000,
  0x0000, 0x0000, 0x000f, 0x0000,
  0x0000, 0x0000, 0x0000, 0x000f,
 
  0x0000, 0x0000, 0x0000, 0x00f0,
  0x0000, 0x0000, 0x0000, 0x0f00,
  0x0000, 0x0000, 0x0000, 0xf000,
  0x0000, 0x0000, 0xf000, 0x0000,
  0x0000, 0xf000, 0x0000, 0x0000,
  0xf000, 0x0000, 0x0000, 0x0000,

  0x0f00, 0x0000, 0x0000, 0x0000,
  0x00f0, 0x0000, 0x0000, 0x0000,
  0x000f, 0x0000, 0x0000, 0x0000,
   
};


static uint16_t sec = 0;
static uint16_t secuences[] = 
{

    0x0000, 0x0000, 0x0000, 0xffff,
    0x0000, 0x0000, 0x0000, 0xffff,
    0x0000, 0x0000, 0x0000, 0xffff,
    0x0000, 0x0000, 0x0000, 0xffff,
    
    0x0000, 0x0000, 0x0000, 0xffff,    
    0x0000, 0x0000, 0x0001, 0xfffe,
    0x0000, 0x0001, 0x0100, 0xfefe,
    0x0001, 0x0100, 0x0000, 0xfefe,
    
    0x0101, 0x0000, 0x0000, 0xfefe,
    0x0101, 0x0000, 0x0200, 0xfcfe,
    0x0101, 0x0200, 0x0400, 0xf8fe,
    0x0301, 0x0400, 0x0000, 0xf8fe,
    
    0x0701, 0x0000, 0x0008, 0xf8f6,
    0x0701, 0x0008, 0x0000, 0xf8f6,
    0x0709, 0x0000, 0x2000, 0xd8f6,
    0x0709, 0x2000, 0x0002, 0xd8f4,
    
    0x0709, 0x2002, 0x0000, 0xd8f4,
    0x2709, 0x0002, 0x0800, 0xd0f4,
    0x2709, 0x0002, 0x4800, 0x90f4,
    0x2709, 0x0802, 0xC000, 0x10f4,
    
    0x2709, 0xC802, 0x0000, 0x10f4,
    0xe709, 0x0802, 0x0000, 0x10f4,
    0x2709, 0x4802, 0x0000, 0x10f4,
    0x2709, 0x4802, 0x1000, 0x00f4,
    
    0x6709, 0x5802, 0x0000, 0x00f4,
    0x6709, 0xC802, 0x2000, 0x00f4,
    0x6709, 0x0802, 0x0000, 0x00f4,
    0x6f09, 0x2002, 0x0000, 0x00f4,
    
    0x6f09, 0x0002, 0x0000, 0x00f4,
    0x6f09, 0x0002, 0x0004, 0x00f0,
    0x6f09, 0x0006, 0x0000, 0x00f0,
    0x6f0f, 0x0000, 0x0000, 0x00f0,
    
    0x6f0f, 0x0000, 0x0080, 0x0070,
    0x6f0f, 0x0080, 0x0000, 0x0070,
    0x6f8f, 0x0000, 0x0000, 0x0070,
    0x6f8f, 0x0000, 0x0040, 0x0030,
    
    0x6f8f, 0x0040, 0x0000, 0x0030,
    0x6fcf, 0x0000, 0x0000, 0x0030,
    0x6fcf, 0x0000, 0x0030, 0x0000,
    0x6fcf, 0x0300, 0x0000, 0x0000,
    
    0xffff, 0x0000, 0x0000, 0x0000,
    0xffff, 0x0000, 0x0000, 0x0000,
    0xffff, 0x0000, 0x0000, 0x0000,
    0xffff, 0x0000, 0x0000, 0x0000,
    

    
};


// the setup function runs once when you press reset or power the board
void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  for (int i=0; i<20; ++i)
    pinMode(i, OUTPUT);

  cli();//stop interrupts  
  //set timer1 interrupt at 960Hz = 240Hz*4 (4 layers)
  TCCR1A = 0;// set entire TCCR1A register to 0
  TCCR1B = 0;// same for TCCR1B
  TCNT1  = 0;//initialize counter value to 0
  // set compare match register for 1hz increments
  OCR1A = 16666;// = (16*10^6) / (960*1) - 1 (must be <65536)
  // turn on CTC mode
  TCCR1B |= (1 << WGM12);
  // Set for 1 prescaler
  TCCR1B |= (0 << CS12) | (0 << CS11) | (1 << CS10);  
  // enable timer compare interrupt
  TIMSK1 |= (1 << OCIE1A);

  sei();//allow interrupts

  //tests cube
  int s = 0;
  while  (s < (sizeof(test_secuences)/sizeof(*test_secuences))) {
    cube_buffer[0] = test_secuences[s];
    cube_buffer[1] = test_secuences[s+1];
    cube_buffer[2] = test_secuences[s+2];
    cube_buffer[3] = test_secuences[s+3];
    s += 4;
    delay(30);
  }
}


// the loop function runs over and over again forever
void loop() {
   cube_buffer[0] = secuences[sec];
   cube_buffer[1] = secuences[sec+1];
   cube_buffer[2] = secuences[sec+2];
   cube_buffer[3] = secuences[sec+3];
   sec = (sec + 4) % (sizeof(secuences)/sizeof(*secuences));
   delay(500 - 2*sec);
   //uint16_t pattern = 0xffff;
   //render_cube_pattern(&pattern, 0x08);
}



/**
 * This isr is called at 960Hz to render pattern in layers
 * @param layer_pattern points to 16bits value for each layer led
 * @layers the layer(s) where paint the pattern (could be more than one)
 */
void render_cube_pattern(uint16_t* layer_pattern, uint8_t layers){
  PORTD = 0xFF; //turn off all layers
  PORTB = (uint8_t)(*layer_pattern >> 4) & 0b00111111;
  PORTC = (uint8_t)(*layer_pattern >> 10) & 0b00111111;
  PORTD = (layers & 0b00001111) | ((uint8_t)*layer_pattern << 4);  
}

/**
 * timer1 interrupt 960Hz to render one cube layer
 */
ISR(TIMER1_COMPA_vect){
  render_cube_pattern(cube_buffer+layer, 1<<layer );  
  layer = (layer + 1) % (sizeof(cube_buffer)/sizeof(*cube_buffer));
}
